ahora tu tarea es realizar un codigo c++ que me des un codigo c++ para convertir ese documento txt que posea un menu:

1. recibir por consola una ruta a el archivo.txt de la informacion:

esta funcion debe leer el archivo guardando la informacion que contiene para luego guardarla en un archivo.sql que sirva para realizar la carga de datos (Q en caso de ya tener datos debe agregar los nuevos datos sin borrar los ya existentes)

2. salir y cerrar el programa

el archivo de entrada se ve asi (es un .txt):
                         Chocolate Doom 3.1.0
Z_Init: Init zone memory allocation daemon. 
zone memory: 0xf3158c28f010, 2000000 allocated for zone
Using /home/daniel/.local/share/chocolate-doom/ for configuration and saves
V_Init: allocate screens.
M_LoadDefaults: Load system defaults.
saving config in /home/daniel/.local/share/chocolate-doom/default.cfg
W_Init: Init WADfiles.
 adding /home/daniel/DOOM.WAD
BFG Edition: Using workarounds as needed.
===========================================================================
                           The Ultimate DOOM
===========================================================================
 Chocolate Doom is free software, covered by the GNU General Public
 License.  There is NO warranty; not even for MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. You are welcome to change and distribute
 copies under certain conditions. See the source for more information.
===========================================================================
I_Init: Setting up machine state.
OPL_Init: Using driver 'SDL'.
NET_Init: Init network subsystem.
M_Init: Init miscellaneous info.
R_Init: Init DOOM refresh daemon - ..........................
P_Init: Init Playloop state.
S_Init: Setting up sound.
I_SDL_PrecacheSounds: Precaching all sound effects.....................
D_CheckNetGame: Checking network game status.
startskill 2  deathmatch: 0  startmap: 1  startepisode: 1
player 1 of 1 (1 nodes)
Emulating the behavior of the 'Ultimate Doom' executable.
HU_Init: Setting up heads up display.
ST_Init: Init status bar.
When: 2025-11-02 18:30:29 Episode: 1 Map: 1
timestamp	 tic	 x	 y	 z	 angle	 momx	 momy
2025-11-02 18:30:31	 177	 1056	-3616	0	 137.46	 -1	0 	0
2025-11-02 18:30:32	 212	 908	-3463	0	 121.64	 -5	6 	0
2025-11-02 18:30:33	 247	 704	-3292	0	 191.95	 -8	0 	0
2025-11-02 18:30:34	 282	 423	-3244	-8	 176.13	 -9	1 	0
2025-11-02 18:30:35	 317	 135	-3247	104	 179.65	 -9	-1 	0
2025-11-02 18:30:36	 352	 -155	-3254	104	 179.65	 -9	0 	0
2025-11-02 18:30:37	 387	 -248	-3250	128	 206.02	 6	1 	0
2025-11-02 18:30:38	 422	 -117	-3218	104	 300.94	 3	-4 	0
2025-11-02 18:30:39	 457	 53	-3371	104	 327.30	 0	-1 	0
2025-11-02 18:30:40	 495	 98	-3371	104	 348.40	 0	0 	0
2025-11-02 18:30:41	 530	 114	-3371	-8	 4.22	 0	0 	0
2025-11-02 18:30:44	 622	 149	-3281	-8	 49.92	 1	0 	0
2025-11-02 18:30:45	 657	 345	-3290	-8	 355.43	 7	-1 	0
2025-11-02 18:30:46	 705	 474	-3283	-8	 125.51	 -2	3 	0
2025-11-02 18:30:47	 740	 379	-3171	-8	 183.52	 -2	1 	0
2025-11-02 18:30:48	 775	 164	-3168	-8	 153.63	 -8	1 	0
2025-11-02 18:30:49	 810	 132	-3037	-8	 30.59	 4	3 	0
2025-11-02 18:30:50	 845	 301	-3056	-8	 330.82	 3	-1 	0
2025-11-02 18:30:51	 880	 433	-3181	-8	 283.36	 1	-6 	0
2025-11-02 18:30:52	 915	 454	-3242	-8	 337.85	 1	-1 	0
2025-11-02 18:30:53	 950	 527	-3273	-8	 11.25	 1	0 	0
2025-11-02 18:30:54	 985	 702	-3230	0	 55.20	 4	3 	0
2025-11-02 18:30:55	 1020	 872	-3032	0	 37.62	 5	5 	0
2025-11-02 18:30:56	 1055	 1036	-2922	0	 325.55	 1	0 	0
2025-11-02 18:30:57	 1090	 1230	-3004	0	 34.10	 7	0 	0
2025-11-02 18:30:58	 1125	 1323	-2809	0	 81.56	 -1	7 	0
2025-11-02 18:30:59	 1160	 1374	-2556	0	 9.49	 1	2 	0
2025-11-02 18:31:00	 1195	 1428	-2528	0	 246.45	 0	0 	0
2025-11-02 18:31:01	 1230	 1345	-2609	0	 248.20	 -3	-6 	0
2025-11-02 18:31:02	 1265	 1279	-2864	0	 267.54	 -1	-9 	0
2025-11-02 18:31:03	 1300	 1315	-3133	-9	 279.84	 1	-6 	0
2025-11-02 18:31:04	 1335	 1327	-3199	-16	 260.51	 0	-1 	0
2025-11-02 18:31:05	 1372	 1322	-3235	-16	 260.51	 -1	-1 	0
2025-11-02 18:31:06	 1407	 1327	-3154	-16	 260.51	 -1	-2 	0
2025-11-02 18:31:07	 1442	 1290	-3373	0	 260.51	 -2	-9 	0
2025-11-02 18:31:08	 1477	 1263	-3534	0	 299.18	 -1	-1 	0
2025-11-02 18:31:11	 1569	 1313	-3525	0	 141.33	 -4	2 	0
2025-11-02 18:31:12	 1604	 1116	-3367	-2	 132.54	 -7	5 	0
2025-11-02 18:31:13	 1639	 1046	-3124	-16	 51.68	 3	6 	0
2025-11-02 18:31:14	 1674	 1122	-2981	0	 76.29	 1	3 	0
2025-11-02 18:31:15	 1709	 1132	-2948	0	 69.26	 0	0 	0
2025-11-02 18:31:17	 1759	 1080	-3044	0	 69.26	 -1	-1 	0

el archivo de salida (es un .sql) debe de realizar las insercion de datos a una tabla de postgres que se ven asi:
DROP TABLE IF EXISTS UXResponse;
DROP TABLE IF EXISTS UXInstrument;
DROP TABLE IF EXISTS TelemetryEvent;
DROP TABLE IF EXISTS Sector;
DROP TABLE IF EXISTS Map;
DROP TABLE IF EXISTS Game;
DROP TABLE IF EXISTS Player;
DROP TABLE IF EXISTS User;

CREATE TABLE User (
  user_id integer PRIMARY KEY,
  nombre_completo text NOT NULL,
  correo text NOT NULL,
  genero text NOT NULL,
  carrera text NOT NULL
);

CREATE TABLE Player (
  player_id integer PRIMARY KEY,
  user_id integer NOT NULL REFERENCES User(user_id),
  alias varchar(100) NOT NULL
);

CREATE TABLE Game (
  game_id integer PRIMARY KEY,
  player_id integer NOT NULL REFERENCES Player(player_id),
  map_id integer NOT NULL REFERENCES Map(map_id),
  version_software varchar(100) NOT NULL,
  fecha_inicio timestamp NOT NULL,
  fecha_fin timestamp NOT NULL,
  duracion_seconds integer NOT NULL
);

CREATE TABLE Map (
  map_id integer PRIMARY KEY,
  codigo_map varchar(50) NOT NULL,
  nombre_oficial varchar(200) NOT NULL
);

CREATE TABLE Sector (
  sector_id integer PRIMARY KEY,
  map_id integer NOT NULL REFERENCES Map(map_id),
  nombre_sector varchar(150) NOT NULL
);

CREATE TABLE TelemetryEvent (
  event_id integer PRIMARY KEY,
  game_id integer NOT NULL REFERENCES Game(player_id),
  marca_tiempo timestamp NOT NULL,
  tipo_evento varchar(80) NOT NULL,
  pos_x numeric NOT NULL,
  pos_y numeric NOT NULL,
  resultados text NOT NULL
);

CREATE TABLE UXInstrument (
  instrument_id integer PRIMARY KEY,
  nombre varchar(100) NOT NULL,
  tipo varchar(50) NOT NULL
);

CREATE TABLE UXResponse (
  response_id integer PRIMARY KEY,
  user_id integer NOT NULL REFERENCES User(user_id),
  instrument_id integer NOT NULL REFERENCES UXInstrument(instrument_id),
  fecha_respuesta timestamp NOT NULL,
  respuestas_json text NOT NULL
);

y el resultado que debe dar este input dentro de la db debe ser asi:

"User" (
  user_id : autogenerado
  nombre_completo  : preguntar usuario
  genero  : preguntar usuario
  carrera  : preguntar usuario
);

Player (
  player_id  : autogenerado
  user_id  : apunta al user_id de "User"
);

Map (
  map_id  : autogenerado
  codigo_map  : 1 (De When: 2025-11-02 18:30:29 Episode: 1 Map: 1)
  nombre_oficial  : tomar de la lista de mapas de doom 1 (Que toca crear)
);

Game (
  game_id  : autogenerado
  player_id : apunta al player_id de player
  map_id : apunta al map_id de Map
  fecha_inicio  : 2025-11-02 18:30:29 (De When: 2025-11-02 18:30:29 Episode: 1 Map: 1)
  fecha_fin  : 2025-11-02 18:31:17 (De la última telemetria insertada, en este caso 2025-11-02 18:31:17	 1759	 1080	-3044	0	 69.26	 -1	-1 	0)
  duracion_seconds  : 46 (Diferencia entre la primera y última telemetria en segundos)
  episodio : 1 (De When: 2025-11-02 18:30:29 Episode: 1 Map: 1)
);

Sector (
  sector_id  : autogenerado
  map_id  : apunta al map_id de Map
  nombre_sector  : tomar de la lista de sectores de doom 1 (Que toca crear uno por cada mapa)
);

TelemetryEvent (
  event_id  : autogenerado
  game_id  : apunta al game_id de Game
  marca_tiempo  : es el segundo valor en la tabla de telemetria (ejemplo en 2025-11-02 18:30:31	 177	 1056	-3616	0	 137.46	 -1	0 	0 es 177)
  pos_x  : es el tercer valor en la tabla de telemetria (ejemplo en 2025-11-02 18:30:31	 177	 1056	-3616	0	 137.46	 -1	0 	0 es 1056)
  pos_y  : es el cuarto valor en la tabla de telemetria (ejemplo en 2025-11-02 18:30:31	 177	 1056	-3616	0	 137.46	 -1	0 	0 es -3616)
);

UXInstrument (
  instrument_id  : autogenerado
  nombre  : poner 'unknown' por defecto
  tipo  : poner 'unknown' por defecto
);

UXResponse (
  response_id :  autogenerado
  user_id  : apunta al user_id de "User"
  instrument_id  : apunta al instrument_id de UXInstrument
  fecha_respuesta  : poner 'unknown' por defecto
  respuestas_json  : poner 'unknown' por defecto
);



































*-----------------------------Generar README-----------------------------*
tu tarea es realizar el texto para documento README del git que contendra el desarrollo de este proyecto (Lee el enunciado) el contexto es que estamos realizando una consultoria y somos una compañia llamada ColNexus, esto debe ser en español, tambien ten en cuenta que se tendran 3 carpetas que son:

- Code:

Tendra el codigo y los ejecutables tanto de los scripts para transformar los datos en inserciones en la DB, sus archivos son:

* db_struct.sql: este se encarga de limpiar lo que tenga la db y crear las tablas

* loader_script.cxx: este es el script que genera salida_datos.sql que cargara los datos recibiendo el txt de las telemetrias

* salida_datos.sql: tiene las inserciones de las telemetrias a la DB

- Data:

aca todos los integrantes deel equipo cargaran los .txt con sus telemetrias de cada sesion de juego marcada con el nombre de quien la hace y el numero de partida

- Documents: tendra el enunciado deel proyecto y el documento que presentamos como analisis al problema